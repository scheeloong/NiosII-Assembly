.ifndef _nios2_macros_
.equ _nios2_macros_,1

    #--------------------
    # GEQU symbol, value
    #
    # Macro to define a global symbol
    .macro  GEQU sym,val
    .global \sym
    .equ \sym,\val
    .endm

    #--------------------
    # GFUNC symbol
    #
    # Macro to define a global function
    .macro  GFUNC sym
    .global \sym
    .type \sym, @function
    \sym:
    .endm

    #--------------------
    # MOVI32 $reg, imm32
    #
    # Macro to move a 32-bit immediate into a register.
    .macro  MOVI32 reg, val
    movhi \reg, %hi(\val)
    ori \reg, \reg, %lo(\val)
    .endm

	#--------------------
	# MOVIA $reg, address
	#
    # Macro to move a 32-bit address into a register.
    .macro  MOVIA reg, addr
    movhi \reg, %hi(\addr)
    ori \reg, \reg, %lo(\addr)
    .endm

# +----------------------------
# | MOVIK32 reg,value
# |
# | for constants only, no linker action
# | uses only one instruction if possible
# |

    .macro MOVIK32 _dst,_val
    .if   (\_val & 0xffff0000) == 0
        MOVUI \_dst,%lo(\_val)
    .elseif (\_val & 0x0000ffff) == 0
        MOVHI \_dst,%hi(\_val)
    .else
        MOVHI \_dst,%hi(\_val)
        ORI   \_dst,\_dst,%lo(\_val)
    .endif
    .endm


.endif # _nios2_macros_

# end of file

#---------------------------------------------------------------------------------------------------------------
# INTERRUPTS 	
#---------------------------------------------------------------------------------------------------------------
# Make sure interrupt service routine address begins at 0x00000020
 .section .exceptions, "ax" 
# Interrupt Service Routine
ISR:
	# First, save registers used in ISR
	# Save status register to know original configuration of interrupts into estatus
	subi  sp, sp, 28
	stwio et, 0(sp)               # save et
	stwio r19, 4(sp)              # save r19
	stwio ea, 8(sp)               # save ea
	rdctl et, estatus             # save ctl1 = estatus 
	stwio et, 12(sp) #saved estatus at 12(sp)
	stwio r21, 16(sp)
	stwio r17, 20(sp)
	stwio r16, 24(sp)

	rdctl et, ipending # Read pending bit
	andi et, et, 0x1 # Check if first bit is 1 (timer bit)
	bne et, r0, TIMER_IRQ_HANDLER

	rdctl et, ipending # ipending = ctl4
	andi et, et, 0x2 # 2nd bit 	
	bne et, r0, PUSHBUTTON_IRQ_HANDLER

# Timer used to prevent debouncing of switches
TIMER_IRQ_HANDLER: 
	# Update one second speed and sensor
	# Note: It handles writing at the beginning of every loop in main
	# CODE ENTERS HERE

	movia r16, 0x3 # Enable Timer (bit 0) and enable PUSH BUTTON (bit 1) interrupts
	wrctl ienable, r16
	
	# CODE ENDS HERE 
	# Acknowledge timer
	movia r19, TIMER_ADDR # Note: MUST always retrieve from original address again and not register,
						  # in case interrupt occurs before initializing address to a specific register 
	movi r21, 0x2
	stwio r21, 0(r19) # Clear status register for timer to acknowledge interrupt but maintain running bit 
	br 	EXIT_ISR_TIMER

# NOTE KEY0 can't be used as it resets to instruction 0
PUSHBUTTON_IRQ_HANDLER: 
	# Begin Timer 
	movia r16, 0x1 # Enable Timer (bit 0) disable PUSH BUTTON (bit 1) interrupts
	wrctl ienable, r16
	# NOW ONLY START TIMER to prevent deboucing
	movi	r16, 0x5					# set timer to: Start NOW, does not restart timer upon finishing (maintains 20 ms interval) Enable interrupts 
	movia r17, TIMER_ADDR
	stwio	r16, 4(r17)					# write into timer control register 
	
	
	# When a key is presed, its value is 1. 
	movia r16, ADDR_PUSHBUTTONS
	ldwio r16, 12(r16) # Get push button keys value 
	andi r17, r16, 0x2 # Check KEY1 
	beq r0, r17, CHECK_KEY_TWO  
	
# KEY 1 ACTION
	# Turn on LED and Turn on piano 
	movia r16, RED_LEDS
	movia r14, 0x1
	mov r17, r0 
	ori r17, r17, 0x1
	stwio r17, 0(r16)
	#Aknowledge Key
	movia r16, ADDR_PUSHBUTTONS
	stwio r0, 12(r16) # change to r0 later
	# Pre-Call
	add r2, r0, r0 # clear r2, used for return address
	#Save r4, r8
	subi sp, sp, 8
	stw r4, 0(sp)
	stw r8, 4(sp)

	#----------------------
	# Caller Save
	#----------------------
	subi sp, sp, 56
	stw r2, 52(sp)
	stw r3, 48(sp)
	stw r4, 44(sp)
	stw r5, 40(sp)
	stw r6, 36(sp)
	stw r7, 32(sp)
	stw r8, 28(sp)
	stw r9, 24(sp)
	stw r10, 20(sp)
	stw r11, 16(sp)
	stw r12, 12(sp)
	stw r13, 8(sp)
	stw r14, 4(sp)
	stw r15, 0(sp)	
	
	movi r4, 0x1
	call printInstrument1

	#----------------------
	# Caller Restore
	#----------------------
	ldw r2, 52(sp)
	ldw r3, 48(sp)
	ldw r4, 44(sp)
	ldw r5, 40(sp)
	ldw r6, 36(sp)
	ldw r7, 32(sp)
	ldw r8, 28(sp)
	ldw r9, 24(sp)
	ldw r10, 20(sp)
	ldw r11, 16(sp)
	ldw r12, 12(sp)
	ldw r13, 8(sp)
	ldw r14, 4(sp)
	ldw r15, 0(sp)
	addi sp, sp, 56
	
	# Post-Call
	ldw r4, 0(sp)
	ldw r8, 4(sp)
	addi sp, sp, 8
	
	br PUSHBUTTON_IRQ_HANDLER_END
	
CHECK_KEY_TWO: 
	andi r17, r16, 0x4 # Check second bit, note: r16 must still be containing key values 
	beq r0, r17, CHECK_KEY_THREE
# KEY 2 ACTION =>  TUrn off led, dont play any sound
	movia r14, 0x0 
	movia r16, RED_LEDS
	mov r17, r0 
	stwio r17, 0(r16)
	# Acknowledge Key 
	movia r16, ADDR_PUSHBUTTONS
	stwio r0, 12(r16) # change to r0 later
	# Pre-Call
	add r2, r0, r0 # clear r2, used for return address
	#Save r4, r8
	subi sp, sp, 8
	stw r4, 0(sp)
	stw r8, 4(sp)

	#----------------------
	# Caller Save
	#----------------------
	subi sp, sp, 56
	stw r2, 52(sp)
	stw r3, 48(sp)
	stw r4, 44(sp)
	stw r5, 40(sp)
	stw r6, 36(sp)
	stw r7, 32(sp)
	stw r8, 28(sp)
	stw r9, 24(sp)
	stw r10, 20(sp)
	stw r11, 16(sp)
	stw r12, 12(sp)
	stw r13, 8(sp)
	stw r14, 4(sp)
	stw r15, 0(sp)		
	
	movi r4, 0x2
	call printOff
	
	#----------------------
	# Caller Restore
	#----------------------
	ldw r2, 52(sp)
	ldw r3, 48(sp)
	ldw r4, 44(sp)
	ldw r5, 40(sp)
	ldw r6, 36(sp)
	ldw r7, 32(sp)
	ldw r8, 28(sp)
	ldw r9, 24(sp)
	ldw r10, 20(sp)
	ldw r11, 16(sp)
	ldw r12, 12(sp)
	ldw r13, 8(sp)
	ldw r14, 4(sp)
	ldw r15, 0(sp)
	addi sp, sp, 56	
	# Post-Call
	ldw r4, 0(sp)
	ldw r8, 4(sp)
	addi sp, sp, 8	
	br PUSHBUTTON_IRQ_HANDLER_END

CHECK_KEY_THREE:
	# Do nothing
	andi r17, r16, 0x8 # Check third bit, note: r16 must still be containing key values 
	beq r0, r17, PUSHBUTTON_IRQ_HANDLER_END	
	# KEY 3 ACTION =>  TUrn on 2 led
	movia r14, 0x2
	movia r16, RED_LEDS
	mov r17, r0 
	ori r17, r17, 0x3 
	stwio r17, 0(r16)
	# Acknowledge Key 
	movia r16, ADDR_PUSHBUTTONS
	stwio r0, 12(r16) # change to r0 later
	
	#Save r4, r8
	subi sp, sp, 8
	stw r4, 0(sp)
	stw r8, 4(sp)
	#----------------------
	# Caller Save
	#----------------------
	subi sp, sp, 56
	stw r2, 52(sp)
	stw r3, 48(sp)
	stw r4, 44(sp)
	stw r5, 40(sp)
	stw r6, 36(sp)
	stw r7, 32(sp)
	stw r8, 28(sp)
	stw r9, 24(sp)
	stw r10, 20(sp)
	stw r11, 16(sp)
	stw r12, 12(sp)
	stw r13, 8(sp)
	stw r14, 4(sp)
	stw r15, 0(sp)		
	
	movi r4, 0x3
	call printInstrument2
	
	#----------------------
	# Caller Restore
	#----------------------
	ldw r2, 52(sp)
	ldw r3, 48(sp)
	ldw r4, 44(sp)
	ldw r5, 40(sp)
	ldw r6, 36(sp)
	ldw r7, 32(sp)
	ldw r8, 28(sp)
	ldw r9, 24(sp)
	ldw r10, 20(sp)
	ldw r11, 16(sp)
	ldw r12, 12(sp)
	ldw r13, 8(sp)
	ldw r14, 4(sp)
	ldw r15, 0(sp)
	addi sp, sp, 56	
	# Post-Call
	ldw r4, 0(sp)
	ldw r8, 4(sp)
	addi sp, sp, 8	
	
	br PUSHBUTTON_IRQ_HANDLER_END
	
PUSHBUTTON_IRQ_HANDLER_END:	
# Acknowledge first before calling any print in C
	br 	EXIT_ISR_PUSH
	
EXIT_ISR_TIMER:
	ldwio et, 12(sp)		# Get previous estatus
#	wrctl estatus, et       # write (ctl1 = estatus) from prev. estatus saved 
	mov r17, et	# Get et original value 
	ori r17, r17, 0x2 		# 00000010
	wrctl estatus, r17
	ldwio ea, 8(sp)         # restore ea
	ldwio r19, 4(sp)        # restore r19
	ldwio et, 0(sp)         # restore et
	ldwio r21, 16(sp)
	ldwio r17, 20(sp)
	ldwio r16, 24(sp)
	addi sp, sp, 28		# Restore stack pointer
	subi ea, ea, 4 			# Correct return address to instruction interrupted
	# Enable interrupts again (restore status to original state) and return 
	# Note: eret automatically writes estatus to status 
	eret 					# Return, note: Might cause an infinite loop here if interrupted at this very instruction 
	
EXIT_ISR_PUSH:
	ldwio et, 12(sp)		# Get previous estatus
#	wrctl estatus, et       # write (ctl1 = estatus) from prev. estatus saved 
	mov r17, et	# Get et original value 
	movia r16, 0xFFFFFFFD
	and r17, r17, r16 # 1111111 ...1101
	wrctl estatus, r17
	ldwio ea, 8(sp)         # restore ea
	ldwio r19, 4(sp)        # restore r19
	ldwio et, 0(sp)         # restore et
	ldwio r21, 16(sp)
	ldwio r17, 20(sp)
	ldwio r16, 24(sp)
	addi sp, sp, 28		# Restore stack pointer
	subi ea, ea, 4 			# Correct return address to instruction interrupted
	# Enable interrupts again (restore status to original state) and return 
	# Note: eret automatically writes estatus to status 
	eret 					# Return, note: Might cause an infinite loop here if interrupted at this very instruction 	
	

#---------------------------------------------------------------------------------------------------------------
	.section .data
	.equ ADDR_AUDIODACFIFO, 0x10003040    # Address of audio
	.equ ADDR_SLIDESWITCHES, 0x10000040	  # Address of slide switches
	# Note, numbertodivide is used!!
	.equ NUMBER_TO_DIVIDE, 3			  # Division on final value to control volume  
	.equ MAX_SAMPLE_SIZE, 200 			  # Max number of samples for each note
	.equ RED_LEDS, 0x10000000
	.equ GREEN_LEDS, 0x10000010
	.equ ADDR_PUSHBUTTONS, 0x10000050
	.equ IRQ_PUSHBUTTONS, 0x02 
	.equ TIMER_ADDR ,0x10002000
	.equ TIMER_LOOP,   1  
	.equ PERIOD_VALUE, 0xf4240 # Counts up to 20 ms for 50 MHz clock 
	.equ LCD_ADDR, 0x10003050
	
#---------------------------------------------------------------------------------------------------------------
# HALF-WORD
	# Align to halfword as want 16 bit numbers to throw to audio codec and not 32 
#---------------------------------------------------------------------------------------------------------------
	.align 1 
	
	#Note1 is 440Hz, Note2 is 220Hz
	# TODO: C program: 
	# 1. Get Note Array
	# 2. Get Sample size of each array 
	# 3. Store each array into the 7 available register arrays big enough to store max sample size 
	
	# Note 1 => Flute C => 109
	# Note 2 => Flute D => 109
	# Note 3 => Flute E => 109
	# Note 4 => Flute F => 109
	# Note 5 => Flute G => 109
	# Note 6 => Flute A => 109
	# Note 7 => Flute B => 109
	
		
	# NOTE: SlideSwitchConfig is not being used now although it is being updated to proper values, regardless if random SW like SW19, SW18 is pressed
	# cause in ADDR_SLIDESWITCHES, the values will be different if SW19 and SW18 is pressed 
	SlideSwitchConfig: 	.hword  0 # Configuration of slide switch, (which switch is being flipped to 1) 
	
	# Final output to be sent to both earphones 
# Replaced by r13	OutputNote: .hword		0		 # Output sample
	
#---------------------------------------------------------------------------------------------------------------
# WORD	
#---------------------------------------------------------------------------------------------------------------
	.align 2
	# State of notes, to keep track which note is pressed
	
	# An array to keep track of which note is pressed
	NotePressed: 				# The words contain the active state for the respective notes, here 2*4 =8 bytes 
	.skip 12			# Enough space for 3 notes (word)
	#Note if did not initialize the register to a value, must .skip 4 if not will not reserve any space
	
	# Number to divide depends on number of notes pressed 

#-----------------------------
# Instrument 1
#-----------------------------
	# Pointer to iterate through each note, note: the value of PointerNoteX is the address of the register not its value 
	PointerNote1:			.word 0
	PointerNote2:			.word 0
	PointerNote3:			.word 0
	PointerNote4:			.word 0
	PointerNote5:			.word 0
	PointerNote6:			.word 0
	PointerNote7:			.word 0
	PointerNote8:			.word 0

#-----------------------------
# Instrument 1 Flute
#-----------------------------
	SampleSizeNote1: 		.word 183
	SampleSizeNote2: 		.word 163
	SampleSizeNote3: 		.word 146
	SampleSizeNote4:		.word 138
	SampleSizeNote5:		.word 124
	SampleSizeNote6:		.word 109
	SampleSizeNote7:		.word 97
	SampleSizeNote8:		.word 91


#-----------------------------
# Instrument 1 Flute
#-----------------------------
# C 183
Note1: .word 1873,1858,1830,1784,1724,1652,1571,1487,1399,1310,1221,1131,1043,955,874,794,721,649,581,515,454,396,342,294,249,208,168,128,90,52,17,-20,-61,-103,-149,-195,-249,-304,-366,-429,-503,-582,-670,-763,-856,-953,-1051,-1151,-1250,-1345,-1433,-1511,-1576,-1626,-1661,-1685,-1691,-1680,-1644,-1589,-1509,-1417,-1308,-1192,-1064,-929,-786,-636,-493,-345,-212,-79,40,156,258,352,431,495,546,580,610,625,634,628,614,587,546,493,429,362,289,213,130,45,-39,-118,-193,-260,-320,-371,-414,-450,-479,-496,-506,-507,-503,-495,-482,-468,-448,-430,-403,-381,-350,-328,-300,-277,-249,-225,-201,-181,-163,-148,-140,-132,-131,-126,-131,-131,-142,-151,-167,-182,-201,-220,-240,-262,-283,-305,-324,-343,-358,-371,-381,-388,-394,-396,-394,-386,-375,-361,-346,-330,-308,-287,-263,-237,-206,-170,-132,-86,-39,20,78,151,230,320,427,538,659,776,907,1033,1171,1295,1422,1529,1630,1713,1776,1831,1866
# D 163 
Note2: .word 1880,1864,1831,1779,1713,1632,1544,1449,1351,1250,1148,1049,952,860,772,690,612,539,470,406,345,290,238,191,145,105,62,21,-24,-68,-114,-167,-222,-284,-351,-426,-506,-597,-691,-794,-901,-1013,-1127,-1237,-1344,-1440,-1525,-1594,-1646,-1677,-1687,-1674,-1638,-1579,-1498,-1395,-1271,-1127,-972,-808,-644,-481,-322,-169,-25,106,226,328,424,496,559,598,627,636,633,614,583,538,481,413,333,251,159,67,-31,-120,-207,-279,-346,-394,-439,-470,-490,-503,-505,-504,-491,-479,-455,-435,-404,-380,-346,-321,-291,-261,-233,-206,-183,-163,-147,-135,-128,-125,-126,-130,-140,-148,-168,-184,-208,-228,-254,-277,-303,-324,-345,-362,-374,-389,-394,-397,-392,-384,-372,-359,-340,-321,-295,-272,-239,-206,-167,-125,-77,-19,47,129,215,319,427,554,684,827,971,1116,1264,1404,1536,1648,1740,1808,1852
# E 146
Note3: .word 1874,1874,1846,1793,1721,1633,1533,1425,1313,1199,1088,979,875,778,683,596,513,440,369,306,246,193,142,95,47,0,-49,-101,-156,-218,-286,-363,-447,-542,-646,-760,-880,-1004,-1132,-1256,-1376,-1482,-1574,-1641,-1685,-1697,-1682,-1634,-1559,-1454,-1324,-1173,-1005,-828,-644,-461,-282,-114,41,180,302,405,489,551,599,622,633,618,593,543,485,405,321,219,111,11,-97,-187,-279,-347,-412,-450,-485,-498,-509,-502,-495,-478,-453,-427,-394,-363,-327,-295,-260,-229,-198,-174,-153,-139,-129,-124,-124,-131,-140,-156,-172,-196,-220,-249,-274,-297,-326,-345,-369,-378,-393,-392,-396,-384,-376,-354,-338,-309,-279,-249,-210,-170,-118,-64,5,81,174,280,404,539,690,849,1017,1184,1347,1495,1627,1732,1813,1861
# F 138
Note4: .word 1878,1854,1804,1729,1636,1530,1414,1296,1174,1057,944,834,733,635,547,463,388,317,255,197,146,97,46,-4,-57,-112,-172,-239,-315,-399,-495,-601,-720,-845,-975,-1110,-1241,-1369,-1483,-1580,-1651,-1695,-1704,-1681,-1621,-1530,-1406,-1254,-1082,-893,-697,-499,-308,-126,41,189,318,424,509,574,614,636,632,615,570,516,433,348,240,137,19,-95,-191,-287,-356,-421,-458,-490,-500,-506,-496,-483,-458,-432,-402,-366,-333,-296,-262,-228,-197,-171,-150,-135,-127,-124,-127,-134,-148,-165,-188,-211,-241,-268,-300,-324,-352,-368,-379,-393,-391,-392,-376,-368,-342,-324,-291,-262,-221,-179,-126,-65,5,90,191,307,442,589,752,920,1097,1267,1427,1573,1692,1786,1845
# G 124
Note5: .word 1864,1816,1616,1338,1046,780,550,360,208,82,-40,-184,-366,-608,-904,-1226,-1514,-1676,-1648,-1424,-1044,-580,-124,250,502,618,612,488,270,4,-246,-422,-494,-496,-448,-372,-288,-206,-144,-122,-134,-174,-236,-306,-362,-394,-386,-342,-274,-178,-38,172,478,870,1294,1646,1840
# A  109
Note6: .word 1876,1849,1773,1662,1526,1379,1229,1080,935,798,670,558,455,363,279,204,139,75,13,-56,-126,-207,-297,-401,-524,-660,-814,-977,-1148,-1309,-1454,-1573,-1658,-1701,-1684,-1609,-1477,-1302,-1097,-865,-623,-373,-146,66,239,388,495,575,623,637,615,556,469,359,235,96,-44,-178,-291,-379,-442,-480,-501,-500,-488,-460,-426,-384,-340,-297,-251,-213,-170,-145,-125,-121,-123,-131,-150,-172,-206,-240,-279,-313,-344,-369,-387,-396,-395,-382,-361,-331,-297,-255,-206,-147,-77,15,127,272,436,629,833,1056,1272,1478,1646,1773,1850
# B 97
Note7: .word 34,151,297,463,658,866,1090,1305,1503,1664,1783,1858,1876,1849,1773,1662,1526,1379,1229,1080,935,798,670,558,455,363,279,204,139,75,13,-56,-126,-207,-297,-401,-524,-660,-814,-977,-1148,-1309,-1454,-1573,-1658,-1701,-1684,-1609,-1477,-1302,-1097,-865,-623,-373,-146,66,239,388,495,575,623,637,615,556,469,359,235,96,-44,-178,-291,-379,-442,-480,-501,-500,-488,-460,-426,-384,-340,-297,-251,-213,-170,-145,-125,-121,-123,-131,-150,-172,-206,-240,-279,-313,-344
# High C 91
Note8: .word 826,797,718,609,456,289,99,-94,-280,-449,-591,-703,-777,-818,-824,-803,-754,-684,-598,-501,-389,-274,-149,-26,103,222,344,453,557,647,722,790,839,879,903,919,926,925,924,915,911,901,899,899,900,910,916,930,937,950,957,964,965,956,940,896,838,747,635,494,330,147,-57,-269,-496,-724,-960,-1191,-1408,-1611,-1780,-1918,-2005,-2047,-2032,-1969,-1852,-1697,-1502,-1286,-1051,-811,-570,-337,-112,97,291,463,611,727,811

#-----------------------------
# Instrument 2
#-----------------------------
	# Pointer to iterate through each note, note: the value of PointerNoteX is the address of the register not its value 
	PointerNote21:			.word 0
	PointerNote22:			.word 0
	PointerNote23:			.word 0
	PointerNote24:			.word 0
	PointerNote25:			.word 0
	PointerNote26:			.word 0
	PointerNote27:			.word 0
	PointerNote28:			.word 0
	
# Used to create delay effect
PointerNote21a:			.word 0
CounterNote21a:			.word 0
PointerNote22a:			.word 0
CounterNote22a:			.word 0
PointerNote23a:			.word 0
CounterNote23a:			.word 0
PointerNote24a:			.word 0
CounterNote24a:			.word 0
PointerNote25a:			.word 0
CounterNote25a:			.word 0
PointerNote26a:			.word 0
CounterNote26a:			.word 0
PointerNote27a:			.word 0
CounterNote27a:			.word 0
PointerNote28a:			.word 0
CounterNote28a:			.word 0

#-----------------------------
# Instrument 2 Trumpet
#-----------------------------
	SampleSizeNote21:		.word 245
	SampleSizeNote22:		.word 218
	SampleSizeNote23:		.word 194
	SampleSizeNote24:		.word 183
	SampleSizeNote25: 		.word 164
	SampleSizeNote26: 		.word 146
	SampleSizeNote27: 		.word 130
	SampleSizeNote28: 		.word 123
	
# TEMP
#	SampleSizeNote1: 		.word 501
#-----------------------------
# Instrument 2: Trumpet
#-----------------------------
# G Trumpet 245
Note21: .word 2018,2017,1909,1713,1454,1160,855,558,282,35,-177,-356,-501,-619,-714,-791,-850,-896,-926,-940,-937,-919,-888,-847,-801,-752,-705,-660,-620,-582,-545,-507,-469,-429,-387,-345,-301,-256,-210,-161,-111,-60,-9,40,86,127,163,193,217,236,251,261,268,273,275,273,268,259,244,226,204,180,154,131,108,91,75,63,47,32,14,-12,-27,-53,-68,-87,-100,-110,-116,-117,-117,-115,-114,-113,-112,-116,-117,-124,-127,-132,-133,-135,-132,-130,-125,-117,-114,-107,-106,-104,-108,-112,-119,-124,-129,-130,-129,-125,-117,-108,-94,-80,-65,-50,-35,-22,-8,5,18,31,43,53,62,66,66,60,52,39,26,13,1,-11,-22,-29,-33,-35,-36,-35,-32,-27,-20,-15,-9,-4,2,8,9,7,-1,-13,-29,-48,-68,-87,-103,-115,-122,-125,-123,-118,-111,-103,-94,-87,-82,-80,-81,-83,-89,-94,-101,-109,-117,-126,-132,-143,-146,-156,-155,-165,-163,-168,-166,-159,-150,-136,-122,-106,-91,-80,-69,-63,-56,-55,-52,-52,-54,-55,-59,-58,-61,-59,-60,-56,-54,-46,-36,-23,-7,9,23,31,34,30,23,14,8,4,5,9,17,27,38,49,59,69,80,93,109,125,143,162,184,209,238,276,328,406,522,692,918,1193,1484,1750,1945
# A Trumpet 218
Note22: .word 2020,1953,1767,1494,1172,834,506,205,-59,-279,-457,-597,-706,-789,-853,-899,-926,-932,-918,-888,-844,-792,-737,-685,-638,-595,-554,-513,-470,-426,-380,-332,-284,-233,-181,-125,-68,-11,43,93,138,176,206,229,245,258,267,272,273,269,261,248,229,205,177,148,121,99,81,64,48,30,11,-12,-34,-57,-80,-93,-109,-111,-117,-112,-112,-109,-110,-112,-115,-121,-126,-130,-134,-132,-131,-125,-122,-113,-109,-104,-105,-109,-115,-122,-126,-130,-128,-125,-115,-105,-89,-72,-54,-39,-24,-8,6,21,34,48,58,65,66,60,50,36,21,6,-8,-19,-28,-33,-37,-36,-33,-28,-23,-16,-9,-2,4,8,9,6,-3,-21,-42,-65,-86,-104,-116,-123,-124,-119,-111,-102,-93,-86,-82,-80,-85,-85,-96,-97,-111,-120,-127,-137,-143,-152,-156,-160,-164,-164,-163,-154,-142,-126,-109,-93,-77,-68,-59,-56,-52,-54,-54,-58,-58,-60,-60,-59,-58,-55,-50,-40,-26,-7,10,24,32,33,27,18,9,5,6,13,21,33,44,56,67,79,94,112,132,152,176,203,237,281,344,441,590,805,1083,1400,1709,1948
# B Trumpet 194
Note23: .word 1287,1275,1249,1204,1142,1063,963,837,683,504,305,92,-132,-355,-569,-766,-938,-1079,-1186,-1260,-1303,-1321,-1315,-1287,-1238,-1178,-1108,-1031,-946,-856,-763,-669,-578,-487,-399,-315,-236,-164,-100,-46,-1,35,61,78,84,83,74,63,48,32,14,-3,-20,-36,-50,-64,-73,-85,-92,-101,-106,-113,-118,-126,-132,-139,-146,-151,-160,-160,-164,-163,-165,-162,-159,-153,-146,-139,-129,-120,-108,-97,-85,-74,-66,-55,-49,-40,-35,-28,-24,-19,-13,-13,-7,-8,-6,-9,-9,-13,-17,-22,-28,-33,-39,-44,-50,-55,-59,-65,-68,-74,-75,-79,-78,-83,-82,-86,-87,-86,-88,-89,-94,-96,-103,-104,-112,-115,-124,-131,-138,-147,-155,-163,-169,-179,-188,-199,-208,-216,-226,-234,-241,-248,-252,-257,-257,-260,-254,-254,-244,-239,-224,-213,-193,-173,-151,-124,-96,-64,-32,4,40,80,120,162,203,244,286,329,371,412,453,494,535,577,619,662,706,752,798,845,892,939,984,1028,1071,1113,1153,1190,1223,1251,1273,1286
# C Trumpet 183
Note24: .word 1290,1281,1258,1217,1158,1077,971,837,674,486,274,45,-193,-429,-651,-848,-1013,-1143,-1236,-1294,-1318,-1315,-1288,-1242,-1179,-1104,-1020,-930,-835,-736,-637,-539,-446,-355,-269,-189,-119,-58,-8,32,61,78,84,82,73,60,43,25,6,-11,-28,-44,-58,-72,-81,-91,-98,-107,-113,-120,-126,-133,-141,-147,-154,-158,-165,-164,-167,-163,-161,-154,-147,-138,-129,-118,-106,-96,-82,-71,-60,-51,-44,-36,-31,-25,-21,-16,-12,-10,-5,-9,-8,-12,-13,-18,-23,-30,-37,-41,-49,-51,-59,-63,-68,-73,-75,-79,-79,-84,-83,-87,-84,-87,-89,-91,-97,-100,-106,-108,-116,-120,-130,-136,-146,-153,-162,-170,-179,-189,-200,-209,-220,-226,-239,-244,-254,-255,-257,-258,-256,-254,-245,-237,-223,-210,-189,-169,-142,-114,-81,-46,-10,29,68,111,154,198,243,287,332,377,421,464,507,551,595,641,687,735,784,834,884,933,981,1028,1073,1118,1160,1198,1232,1260,1279
# D Trumpet 164
Note25: .word 1288,1286,1269,1233,1175,1088,970,816,627,407,160,-104,-372,-625,-848,-1029,-1166,-1259,-1312,-1324,-1301,-1250,-1180,-1096,-1002,-900,-790,-679,-568,-461,-359,-263,-175,-98,-34,15,51,74,84,83,72,55,35,14,-6,-26,-44,-60,-74,-84,-95,-103,-112,-118,-126,-133,-142,-150,-155,-160,-163,-167,-164,-163,-153,-147,-135,-125,-110,-97,-82,-70,-59,-49,-43,-31,-27,-19,-17,-11,-9,-6,-8,-9,-14,-16,-25,-29,-39,-44,-51,-56,-62,-69,-71,-77,-76,-82,-84,-86,-87,-86,-88,-89,-95,-99,-105,-110,-116,-126,-133,-142,-151,-159,-171,-180,-194,-203,-217,-225,-239,-246,-252,-257,-258,-259,-254,-249,-237,-224,-205,-183,-157,-127,-92,-54,-14,30,75,123,172,222,272,323,372,422,471,520,569,619,671,723,778,833,890,945,999,1050,1101,1149,1193,1232,1262,1281
# E Trumpet 146
Note26: .word 1288,1280,1248,1189,1096,966,793,575,316,25,-277,-567,-825,-1033,-1184,-1276,-1317,-1311,-1270,-1200,-1108,-1002,-886,-764,-639,-517,-398,-288,-188,-101,-28,26,63,82,84,75,57,36,12,-10,-33,-51,-68,-81,-93,-104,-113,-121,-129,-138,-147,-156,-162,-165,-166,-164,-159,-153,-141,-130,-114,-101,-83,-71,-55,-47,-35,-29,-19,-15,-13,-6,-8,-5,-12,-12,-21,-25,-36,-41,-52,-57,-66,-71,-77,-79,-82,-83,-86,-85,-88,-87,-95,-97,-101,-110,-115,-127,-136,-148,-157,-170,-181,-195,-207,-220,-231,-242,-251,-257,-260,-259,-254,-246,-233,-216,-193,-165,-131,-93,-49,-3,47,99,153,208,265,321,377,432,487,543,598,656,714,776,839,902,962,1022,1080,1135,1185,1228,1262,1284
# Fsharp Trumpet 130 
Note27: .word 1275,1275,1255,1216,1145,1032,867,651,396,121,-153,-408,-630,-811,-955,-1063,-1143,-1192,-1214,-1206,-1178,-1137,-1087,-1034,-969,-898,-815,-730,-642,-561,-484,-415,-352,-294,-244,-198,-160,-127,-102,-82,-65,-51,-37,-26,-16,-6,3,13,20,29,35,44,49,60,66,78,83,88,96,99,109,114,129,136,151,156,167,167,170,164,151,141,120,100,72,40,2,-44,-88,-141,-186,-233,-279,-318,-359,-388,-420,-438,-459,-466,-474,-470,-464,-450,-427,-403,-369,-335,-294,-253,-207,-160,-107,-52,4,61,118,174,228,282,334,384,433,481,528,573,616,660,706,753,803,855,911,970,1030,1091,1149,1201,1239,1262
# High G Trumpet 123
Note28: .word 1278,1271,1239,1174,1072,920,710,449,155,-140,-410,-640,-827,-976,-1086,-1162,-1202,-1213,-1193,-1156,-1108,-1052,-989,-913,-828,-735,-645,-558,-480,-407,-341,-281,-227,-183,-145,-116,-92,-71,-55,-41,-30,-16,-7,3,12,21,30,36,44,50,62,69,82,86,96,98,104,115,122,137,146,161,166,171,168,161,151,133,115,86,56,16,-27,-75,-127,-177,-231,-277,-325,-361,-394,-423,-443,-463,-469,-474,-466,-458,-437,-413,-379,-342,-301,-255,-208,-153,-99,-40,18,78,137,196,254,310,365,417,468,517,564,611,657,706,757,811,866,925,987,1053,1118,1175,1222,1254,1273



#-----------------------------
# Instrument 2 Sound Effects GGGG, uncommen these when commenting out instrument 2
#-----------------------------
	# SoundEffect from Trumpet when combined 
	# G 244 Violin G4
#	Note21: .word 1317,1305,1292,1264,1237,1199,1166,1131,1101,1074,1040,1003,955,899,832,757,677,599,524,458,396,343,290,244,196,152,111,78,53,34,26,26,40,60,94,129,171,206,236,256,267,277,284,302,323,356,385,411,420,409,371,309,224,130,32,-62,-149,-234,-312,-394,-472,-553,-621,-674,-698,-697,-674,-640,-606,-573,-553,-532,-522,-511,-509,-512,-528,-558,-603,-661,-720,-774,-806,-818,-798,-760,-707,-655,-613,-588,-584,-593,-613,-629,-640,-637,-626,-610,-599,-596,-607,-631,-668,-718,-778,-853,-932,-1015,-1089,-1144,-1167,-1149,-1090,-990,-867,-727,-594,-476,-389,-334,-314,-323,-357,-406,-463,-519,-570,-605,-624,-618,-599,-562,-527,-497,-489,-509,-565,-651,-750,-846,-915,-953,-947,-913,-850,-775,-693,-615,-545,-488,-448,-429,-433,-458,-503,-554,-606,-639,-647,-619,-557,-466,-360,-257,-168,-116,-99,-129,-190,-288,-400,-524,-652,-781,-908,-1027,-1132,-1206,-1247,-1241,-1197,-1106,-985,-831,-659,-473,-278,-84,111,292,464,612,739,836,907,950,973,977,968,950,930,912,899,894,899,915,940,973,1004,1035,1051,1057,1041,1011,969,921,874,832,799,775,765,768,788,822,870,928,991,1055,1111,1160,1194,1218,1231,1240,1244,1249,1254,1261,1267,1276,1281,1289,1292,1298
	# G Trumpet 245
#	Note22: .word 2018,2017,1909,1713,1454,1160,855,558,282,35,-177,-356,-501,-619,-714,-791,-850,-896,-926,-940,-937,-919,-888,-847,-801,-752,-705,-660,-620,-582,-545,-507,-469,-429,-387,-345,-301,-256,-210,-161,-111,-60,-9,40,86,127,163,193,217,236,251,261,268,273,275,273,268,259,244,226,204,180,154,131,108,91,75,63,47,32,14,-12,-27,-53,-68,-87,-100,-110,-116,-117,-117,-115,-114,-113,-112,-116,-117,-124,-127,-132,-133,-135,-132,-130,-125,-117,-114,-107,-106,-104,-108,-112,-119,-124,-129,-130,-129,-125,-117,-108,-94,-80,-65,-50,-35,-22,-8,5,18,31,43,53,62,66,66,60,52,39,26,13,1,-11,-22,-29,-33,-35,-36,-35,-32,-27,-20,-15,-9,-4,2,8,9,7,-1,-13,-29,-48,-68,-87,-103,-115,-122,-125,-123,-118,-111,-103,-94,-87,-82,-80,-81,-83,-89,-94,-101,-109,-117,-126,-132,-143,-146,-156,-155,-165,-163,-168,-166,-159,-150,-136,-122,-106,-91,-80,-69,-63,-56,-55,-52,-52,-54,-55,-59,-58,-61,-59,-60,-56,-54,-46,-36,-23,-7,9,23,31,34,30,23,14,8,4,5,9,17,27,38,49,59,69,80,93,109,125,143,162,184,209,238,276,328,406,522,692,918,1193,1484,1750,1945
	# G 124
#	Note23: .word 1864,1816,1616,1338,1046,780,550,360,208,82,-40,-184,-366,-608,-904,-1226,-1514,-1676,-1648,-1424,-1044,-580,-124,250,502,618,612,488,270,4,-246,-422,-494,-496,-448,-372,-288,-206,-144,-122,-134,-174,-236,-306,-362,-394,-386,-342,-274,-178,-38,172,478,870,1294,1646,1840
	# G Trumpet+VIolin 244
#	Note24: .word 1668,1661,1601,1489,1346,1180,1011,845,692,555,432,324,227,140,59,-17,-86,-148,-201,-241,-270,-288,-299,-301,-302,-300,-297,-291,-283,-274,-259,-240,-214,-184,-146,-108,-65,-25,13,48,78,109,138,171,205,242,274,302,319,323,311,285,246,202,154,106,60,13,-34,-84,-134,-186,-233,-271,-295,-303,-299,-288,-279,-270,-269,-272,-274,-282,-288,-299,-314,-334,-359,-389,-418,-444,-460,-465,-455,-438,-412,-389,-370,-360,-358,-364,-372,-379,-382,-377,-370,-358,-352,-350,-357,-371,-393,-421,-453,-491,-530,-570,-603,-626,-630,-614,-577,-520,-451,-374,-301,-235,-185,-151,-135,-135,-147,-170,-198,-229,-259,-283,-299,-302,-299,-286,-274,-263,-261,-272,-300,-343,-391,-436,-467,-484,-478,-458,-424,-383,-342,-304,-273,-250,-238,-238,-250,-272,-303,-334,-364,-382,-385,-368,-334,-284,-227,-172,-125,-98,-90,-106,-139,-191,-250,-316,-384,-453,-520,-585,-639,-681,-701,-703,-680,-637,-575,-495,-404,-304,-200,-95,10,106,198,275,342,391,428,449,460,461,455,446,435,427,420,419,423,435,452,475,499,522,537,544,538,521,496,468,441,418,402,392,391,398,413,436,465,499,536,574,610,643,669,690,708,725,741,763,791,834,895,984,1100,1241,1388,1524
	# E 146
#	Note25: .word 1874,1874,1846,1793,1721,1633,1533,1425,1313,1199,1088,979,875,778,683,596,513,440,369,306,246,193,142,95,47,0,-49,-101,-156,-218,-286,-363,-447,-542,-646,-760,-880,-1004,-1132,-1256,-1376,-1482,-1574,-1641,-1685,-1697,-1682,-1634,-1559,-1454,-1324,-1173,-1005,-828,-644,-461,-282,-114,41,180,302,405,489,551,599,622,633,618,593,543,485,405,321,219,111,11,-97,-187,-279,-347,-412,-450,-485,-498,-509,-502,-495,-478,-453,-427,-394,-363,-327,-295,-260,-229,-198,-174,-153,-139,-129,-124,-124,-131,-140,-156,-172,-196,-220,-249,-274,-297,-326,-345,-369,-378,-393,-392,-396,-384,-376,-354,-338,-309,-279,-249,-210,-170,-118,-64,5,81,174,280,404,539,690,849,1017,1184,1347,1495,1627,1732,1813,1861
	# D 163 
#	Note26: .word 1880,1864,1831,1779,1713,1632,1544,1449,1351,1250,1148,1049,952,860,772,690,612,539,470,406,345,290,238,191,145,105,62,21,-24,-68,-114,-167,-222,-284,-351,-426,-506,-597,-691,-794,-901,-1013,-1127,-1237,-1344,-1440,-1525,-1594,-1646,-1677,-1687,-1674,-1638,-1579,-1498,-1395,-1271,-1127,-972,-808,-644,-481,-322,-169,-25,106,226,328,424,496,559,598,627,636,633,614,583,538,481,413,333,251,159,67,-31,-120,-207,-279,-346,-394,-439,-470,-490,-503,-505,-504,-491,-479,-455,-435,-404,-380,-346,-321,-291,-261,-233,-206,-183,-163,-147,-135,-128,-125,-126,-130,-140,-148,-168,-184,-208,-228,-254,-277,-303,-324,-345,-362,-374,-389,-394,-397,-392,-384,-372,-359,-340,-321,-295,-272,-239,-206,-167,-125,-77,-19,47,129,215,319,427,554,684,827,971,1116,1264,1404,1536,1648,1740,1808,1852
	# C 183
#	Note27: .word 1873,1858,1830,1784,1724,1652,1571,1487,1399,1310,1221,1131,1043,955,874,794,721,649,581,515,454,396,342,294,249,208,168,128,90,52,17,-20,-61,-103,-149,-195,-249,-304,-366,-429,-503,-582,-670,-763,-856,-953,-1051,-1151,-1250,-1345,-1433,-1511,-1576,-1626,-1661,-1685,-1691,-1680,-1644,-1589,-1509,-1417,-1308,-1192,-1064,-929,-786,-636,-493,-345,-212,-79,40,156,258,352,431,495,546,580,610,625,634,628,614,587,546,493,429,362,289,213,130,45,-39,-118,-193,-260,-320,-371,-414,-450,-479,-496,-506,-507,-503,-495,-482,-468,-448,-430,-403,-381,-350,-328,-300,-277,-249,-225,-201,-181,-163,-148,-140,-132,-131,-126,-131,-131,-142,-151,-167,-182,-201,-220,-240,-262,-283,-305,-324,-343,-358,-371,-381,-388,-394,-396,-394,-386,-375,-361,-346,-330,-308,-287,-263,-237,-206,-170,-132,-86,-39,20,78,151,230,320,427,538,659,776,907,1033,1171,1295,1422,1529,1630,1713,1776,1831,1866
	# G 501
#	Note28: .word 445,505,581,666,744,813,866,904,927,941,952,952,915,824,675,496,325,196,132,150,248,407,579,711,768,742,656,541,420,307,202,108,28,-33,-77,-113,-149,-195,-249,-301,-337,-337,-309,-277,-275,-312,-373,-434,-490,-541,-577,-578,-536,-493,-484,-528,-587,-617,-589,-509,-390,-254,-108,30,150,250,319,356,353,327,295,276,269,253,204,105,-27,-169,-286,-374,-420,-425,-366,-251,-112,-3,40,32,6,-11,-20,-33,-55,-79,-100,-119,-136,-149,-141,-113,-50,45,172,314,430,493,485,431,344,247,141,49,-9,-20,2,19,11,-25,-59,-83,-91,-91,-78,-40,24,110,196,275,333,374,398,417,435,450,439,381,262,99,-81,-236,-337,-362,-306,-176,-9,146,241,253,196,99,-13,-128,-247,-358,-453,-521,-565,-593,-615,-643,-678,-725,-765,-779,-762,-727,-707,-717,-756,-807,-857,-895,-919,-911,-873,-819,-778,-776,-807,-844,-849,-802,-699,-560,-401,-247,-106,12,100,155,172,165,143,129,129,137,126,70,-36,-172,-301,-407,-479,-515,-487,-389,-238,-93,-5,22,14,7,8,3,-10,-27,-41,-51,-55,-55,-38,-5,53,138,257,409,560,677,720,699,625,532,426,333,262,240,256,278,282,250,208,171,160,165,184,217,268,342,427,514,583,638,672,695,712,730,737,712,622,472,283,105,-26,-88,-73,25,189,371,508,556,522,441,345,242,128,14,-88,-165,-220,-262,-298,-334,-374,-429,-483,-518,-516,-483,-449,-445,-480,-537,-597,-648,-692,-717,-715,-686,-650,-644,-674,-724,-748,-723,-641,-521,-379,-235,-94,30,128,198,234,242,226,200,178,169,158,115,21,-112,-248,-366,-453,-514,-521,-456,-318,-164,-58,-22,-34,-50,-55,-60,-75,-97,-117,-133,-148,-166,-173,-164,-130,-73,20,147,290,419,491,499,449,369,268,162,62,3,-6,19,46,39,8,-31,-50,-53,-44,-23,16,84,169,259,336,403,450,482,499,510,520,515,466,357,192,11,-148,-249,-272,-205,-63,117,276,365,370,310,214,107,-7,-118,-225,-313,-376,-419,-446,-471,-494,-531,-569,-610,-624,-604,-564,-534,-540,-580,-635,-683,-725,-747,-743,-697,-634,-588,-586,-624,-658,-656,-599,-499,-363,-210,-46,99,220,307,360,383,378,357,337,337,348,342,285,175,38,-87,-182,-253,-286,-263,-159,-8,136,220,242,235,230,233,231,219,203,192,183,176,178,195,233,290,376,499,653,811,920,958,923,853,760,661,560,490,465,488,519,519,489,445,416,402,401,409,439,498,576,659,733,801,855,896,920,936,953
#	SampleSizeNote28: 		.word 501
#	SampleSizeNote27: 		.word 183
#	SampleSizeNote26: 		.word 163
#	SampleSizeNote25: 		.word 146
#	SampleSizeNote24:		.word 244
#	SampleSizeNote23:		.word 124
#	SampleSizeNote22:		.word 245
#	SampleSizeNote21:		.word 244
#-----------------------------




#	Note1: 	.word   2740, 4237 ,5717, 7183,  8620, 10034, 11407, 12750, 14046, 15297, 16499, 17641, 18730, 19754, 20714, 21603, 22424, 23167, 23835, 24424, 24931, 25356, 25698, 25953, 26122, 26206, 26201, 26111, 25932, 25672, 25318, 24892, 24371, 23779, 23103, 22350, 21528, 20627, 19665, 18632, 17542, 16390, 15186, 13929, 12630, 11285, 9904, 8493, 7048, 5586, 4100,	2603,  1099,  -413,  -1919,  -3422,  -4912,  -6387,  -7838, -9267, -10662, -12022, -13347, -14618, -15851, -17024, -18145, -19202, -20200, -21125, -21987, -22770, -23481, -24113, -24663, -25137, -25520, -25825, -26041,-26169, -26217, -26169, -26041, -25825, -25521, -25135, -24666, -24109, -23484, -22769, -21986, -21127, -20198, -19203, -18144, -17026, -15848, -14621, -13345, -12021, -10667,  -9260,  -7844,  -6383,  -4914,  -3421,  -1920,   -412,   1099,	
#	Note3: .word 1876,1849,1773,1662,1526,1379,1229,1080,935,798,670,558,455,363,279,204,139,75,13,-56,-126,-207,-297,-401,-524,-660,-814,-977,-1148,-1309,-1454,-1573,-1658,-1701,-1684,-1609,-1477,-1302,-1097,-865,-623,-373,-146,66,239,388,495,575,623,637,615,556,469,359,235,96,-44,-178,-291,-379,-442,-480,-501,-500,-488,-460,-426,-384,-340,-297,-251,-213,-170,-145,-125,-121,-123,-131,-150,-172,-206,-240,-279,-313,-344,-369,-387,-396,-395,-382,-361,-331,-297,-255,-206,-147,-77,15,127,272,436,629,833,1056,1272,1478,1646,1773,1850

#	Note2: 	.word   2740, 4237 ,5717, 7183,  8620, 10034, 11407, 12750, 14046, 15297, 16499, 17641, 18730, 19754, 20714, 21603, 22424, 23167, 23835, 24424, 24931, 25356, 25698, 25953, 26122, 26206, 26201, 26111, 25932, 25672, 25318, 24892, 24371, 23779, 23103, 22350, 21528, 20627, 19665, 18632, 17542, 16390, 15186, 13929, 12630, 11285, 9904, 8493, 7048, 5586, 4100,	2603,  1099,  -413,  -1919,  -3422,  -4912,  -6387,  -7838, -9267, -10662, -12022, -13347, -14618, -15851, -17024, -18145, -19202, -20200, -21125, -21987, -22770, -23481, -24113, -24663, -25137, -25520, -25825, -26041,-26169, -26217, -26169, -26041, -25825, -25521, -25135, -24666, -24109, -23484, -22769, -21986, -21127, -20198, -19203, -18144, -17026, -15848, -14621, -13345, -12021, -10667,  -9260,  -7844,  -6383,  -4914,  -3421,  -1920,   -412,   1099,	
#	Note2:  .word 274,1030,1782,2536,3286,4032,4777,5519,6250,6987,7705,8428,9138,9840,10538,11223,11901,12569,13226,13871,14508,15130,15737,16340,16917,17493,18042,18587,19107,19621,20109,20587,21045,21488,21909,22317,22700,23072,23418,23751,24055,24351,24615,24870,25092,25307,25486,25659,25799,25922,26026,26104,26162,26201,26211,26211,26175,26132,26051,25967,25844,25713,25552,25373,25175,24950,24714,24446,24168,23862,23541,23202,22836,22460,22058,21644,21207,20757,20284,19800,19297,18776,18244,17693,17129,16550,15959,15353,14733,14107,13459,12811,12145,11470,10788,10096,9393,8687,7969,7248,6519,5787,5044,4307,3555,2811,2054,1306,547,-205,-960,-1716,-2466,-3218,-3965,-4709,-5452,-6184,-6920,-7640,-8362,-9075,-9774,-10479,-11156,-11844,-12507,-13167,-13814,-14449,-15074,-15685,-16282,-16869,-17437,-17997,-18534,-19065,-19570,-20069,-20542,-21005,-21448,-21872,-22279,-22669,-23036,-23390,-23718,-24033,-24321,-24595,-24845,-25075,-25287,-25472,-25644,-25785,-25915,-26015,-26098,-26159,-26197,-26212,-26211,-26179,-26137,-26060,-25975,-25857,-25724,-25569,-25389,-25194,-24974,-24732,-24474,-24193,-23891,-23573,-23230,-22872,-22494,-22097,-21681,-21248,-20799,-20326,-19847,-19341,-18826,-18293,-17742,-17183,-16602,-16014,-15408,-14792,-14161,-13522,-12868,-12207,-11531,-10852,-10156,-9462,-8747,-8038,-7311,-6588,-5851,-5115,-4371,-3626,-2876,-2126,-1372,-618

#	Note3:  .word 274,1030,1782,2536,3286,4032,4777,5519,6250,6987,7705,8428,9138,9840,10538,11223,11901,12569,13226,13871,14508,15130,15737,16340,16917,17493,18042,18587,19107,19621,20109,20587,21045,21488,21909,22317,22700,23072,23418,23751,24055,24351,24615,24870,25092,25307,25486,25659,25799,25922,26026,26104,26162,26201,26211,26211,26175,26132,26051,25967,25844,25713,25552,25373,25175,24950,24714,24446,24168,23862,23541,23202,22836,22460,22058,21644,21207,20757,20284,19800,19297,18776,18244,17693,17129,16550,15959,15353,14733,14107,13459,12811,12145,11470,10788,10096,9393,8687,7969,7248,6519,5787,5044,4307,3555,2811,2054,1306,547,-205,-960,-1716,-2466,-3218,-3965,-4709,-5452,-6184,-6920,-7640,-8362,-9075,-9774,-10479,-11156,-11844,-12507,-13167,-13814,-14449,-15074,-15685,-16282,-16869,-17437,-17997,-18534,-19065,-19570,-20069,-20542,-21005,-21448,-21872,-22279,-22669,-23036,-23390,-23718,-24033,-24321,-24595,-24845,-25075,-25287,-25472,-25644,-25785,-25915,-26015,-26098,-26159,-26197,-26212,-26211,-26179,-26137,-26060,-25975,-25857,-25724,-25569,-25389,-25194,-24974,-24732,-24474,-24193,-23891,-23573,-23230,-22872,-22494,-22097,-21681,-21248,-20799,-20326,-19847,-19341,-18826,-18293,-17742,-17183,-16602,-16014,-15408,-14792,-14161,-13522,-12868,-12207,-11531,-10852,-10156,-9462,-8747,-8038,-7311,-6588,-5851,-5115,-4371,-3626,-2876,-2126,-1372,-618

	CounterNote1:			.word 0
	CounterNote2:			.word 0 
	CounterNote3:			.word 0 
	CounterNote4:			.word 0 
	CounterNote5:			.word 0 
	CounterNote6:			.word 0 
	CounterNote7:			.word 0 	
	CounterNote8:			.word 0 

	CounterNote21:			.word 0
	CounterNote22:			.word 0 
	CounterNote23:			.word 0 
	CounterNote24:			.word 0 
	CounterNote25:			.word 0 
	CounterNote26:			.word 0 
	CounterNote27:			.word 0 	
	CounterNote28:			.word 0 

#---------------------------------------------------------------------------------------------------------------
# Register Information 
#---------------------------------------------------------------------------------------------------------------
#-----------------------------
# Return value 
#-----------------------------
# r2 = return value 
#-----------------------------
# Function Parameters
#-----------------------------

#-----------------------------
# Caller Save
#-----------------------------
# r8 = Address of audio
# r9 used to check if slideswitch is open 
# r11 = Check flag for every note
#GLOBAL r10 = Value of Slide Switches
#GLOBAL r12 = holds the number to divide 
#GLOBAL r13 = Final output value of waveform
#GLOBAL r15 = Timer Address 
#GLOBAL r14 = Instrument Select 
#-----------------------------
# Callee Save
#-----------------------------
# r16 = Final Output register address
# r17 = Note1 address
# r18 = ;lkl okll,  address
# r19 = read fifo space CHANGE THIS

# Interrupt also callee saves 
# Interrupt uses 
# r16, r17, r19, r21, ea, 

#---------------------------------------------------------------------------------------------------------------
# Actual Code Begins
#---------------------------------------------------------------------------------------------------------------
.section .text
	

#---------------------------------------------------------------------------------------------------------------
# MAIN
#---------------------------------------------------------------------------------------------------------------

.global main	
main:
	movia sp, 0x20000 # Set stack pointer to large address
	movia r15, TIMER_ADDR 
	movia r18, TIMER_LOOP
 	movia r9, 0x1
	movia r14, 0x1 		#Initialize to play 1st instrument 

# Enable Timer Interrupt & Set Period, start time, loop time also
	movia   r16, PERIOD_VALUE		    # get delay of 1s time period into r16
	sthio	r16, 8(r15)					# store lower half-word of value, according to timer specs 
	srli	r16, r16, 16				# put lower half-word of value into r13 
	sthio	r16, 12(r15)				# store upper half-word of value, according to timer specs 
	
	# NOW ONLY START TIMER 
#	movi	r16, 0x5					# set timer to: Start NOW, does not restart timer upon finishing (maintains 20 ms interval) Enable interrupts 
#	stwio	r16, 4(r15)					# write into timer control register 

  # Enable Push Button Interrupt 
  movia r2, ADDR_PUSHBUTTONS
  movia r3, 0xf
  stwio r3, 8(r2) #Enable push button interrupt for 1, 2 ,3 
  movia r2, IRQ_PUSHBUTTONS
  wrctl ctl3, r2 # Enable bit 5, button interrupt on Processor
  movia r2, 1
  wrctl ctl0, r2 # Enable global Interrupts on Processor
	
# Step2: Unmask IRQ line for peripheral on processor
	movia r16, 0x3 # Enable Timer (bit 0) and PUSH BUTTON (bit 1) interrupts
	wrctl ienable, r16
	
# Step3: Enable interrupts globally in processor 
	addi r16, r0, 0x1
	wrctl status, r16 # Set PIE (bit) to 1 to enable interrupts globally 
	
# Main Program initilization
	# Initialize calculate wave
	#Reset All Notes to the beginning 
	call ResetNote1	
	call ResetNote2
	call ResetNote3
	call ResetNote4
	call ResetNote5
	call ResetNote6
	call ResetNote7
	call ResetNote8

	# Initialize all of instrument 2 notes to the beginning 
	call ResetNote21	
call ResetNote21a	
	
	call ResetNote22
call ResetNote22a	

	call ResetNote23
call ResetNote23a	
	
	call ResetNote24
call ResetNote24a	
	call ResetNote25
call ResetNote25a	

	call ResetNote26
call ResetNote26a	

	call ResetNote27
call ResetNote27a	

	call ResetNote28
call ResetNote28a	

#----------------------------------------------------------------------------------------
# This is the main branch routine that loops forever and calculates OutputNote based on current state of switches stored into NotePressed 
# and outputs it to the audio. Thus, upon silence, set NotePressed to no note is currently pressed so it outputs a value of 0 to the audio 
LoopCalculateWave:
#----------------------------------------------------------------------------------------
		#check the flags for notes and accordingly add the samples and normalise all samples by NumberToDivide and add
	# Automatically calculates next wave 	
movia r10,ADDR_SLIDESWITCHES		# Get address of slide switch device
ldwio r10,0(r10) 				#r10 has the value of the slide switches

# r14 = 0 => No instrument 
# r14 = 1 => instrument 1
# r14 = 2 => instrument 2

LoopCalculateWave2:
	andi r9, r14, 0x1 #check first instrument
	bne r0, r9, PlayInstrument1 # Branch if  r14 is 1 
	andi r9, r14, 0x2 #check second instrument
	bne r0, r9, PlayInstrument2
	# else, dont play anything
	
NoInstrument:
	mov r4, r0 # Make final waveform no value 
	br doneCalculate # Done calculating in the end 
	
PlayInstrument2: 	
		mov r4, r0 # Initialize register to calculate the final waveform
		andi  r9, r10, 0x1
		beq r0, r9, CheckActiveNote22 # If note 1 is active, add it to the register
		call ActiveNote21 #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned

		CheckActiveNote22:
		andi   r9, r10, 0x2
		beq r0, r9, CheckActiveNote23 # If note 1 is active, add it to the register
		call ActiveNote22 #NOTE THIS FUNC CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote23:
		andi   r9, r10, 0x4
		beq r0, r9, CheckActiveNote24
		call ActiveNote23  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote24:
		andi   r9, r10, 0x8
		beq r0, r9, CheckActiveNote25
		call ActiveNote24  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned

		CheckActiveNote25:
		andi   r9, r10, 0x10
		beq r0, r9, CheckActiveNote26
		call ActiveNote25  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote26:
		andi   r9, r10, 0x20
		beq r0, r9, CheckActiveNote27
		call ActiveNote26  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
	
		CheckActiveNote27:
		andi   r9, r10, 0x40
		beq r0, r9, CheckActiveNote28
		call ActiveNote27  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote28:
		andi   r9, r10, 0x80
		beq r0, r9, doneCalculate
		call ActiveNote28  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
br doneCalculate # Done calculating in the end 


PlayInstrument1: 
		mov r4, r0 # Initialize register to calculate the final waveform
		andi  r9, r10, 0x1
		beq r0, r9, CheckActiveNote2 # If note 1 is active, add it to the register
		call ActiveNote1 #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned

		CheckActiveNote2:
		andi   r9, r10, 0x2
		beq r0, r9, CheckActiveNote3 # If note 1 is active, add it to the register
		call ActiveNote2 #NOTE THIS FUNC CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote3:
		andi   r9, r10, 0x4
		beq r0, r9, CheckActiveNote4
		call ActiveNote3  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote4:
		andi   r9, r10, 0x8
		beq r0, r9, CheckActiveNote5
		call ActiveNote4  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned

		CheckActiveNote5:
		andi   r9, r10, 0x10
		beq r0, r9, CheckActiveNote6
		call ActiveNote5  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote6:
		andi   r9, r10, 0x20
		beq r0, r9, CheckActiveNote7
		call ActiveNote6  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned

		CheckActiveNote7:
		andi   r9, r10, 0x40
		beq r0, r9, CheckActiveNote8
		call ActiveNote7  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
		CheckActiveNote8:
		andi   r9, r10, 0x80
		beq r0, r9, doneCalculate
		call ActiveNote8  #NOTE THIS CANNOT USE R10
		mov r4, r2 # Update r4 value based on what is returned
		
doneCalculate:
	add r13, r4, r0		# Store the final output value into r13
	br PlayLoop
#Play through Codec, and checkFifo
PlayLoop2:
	add r2, r0, r0
PlayLoop:			
	movia r8,ADDR_AUDIODACFIFO  # Get address of audio		
	ldwio r19, 4(r8)      # Read fifospace register
	andi r19, r19,0xff000000 # check the write FIFO space in the left channel
	srli r19, r19, 24		# Shift to most right to subtract
	subi r19, r19, 20		# Subtract 20 which is the threshold value 
	blt r19, r0, PlayLoop2	# if less than threshold, poll and wait till there is space, else push value into audio 
		  
Push:						# Pushes the output in the buffer
# REPLACED WITH JUST USING GLOBAL R13	ldhio r19, 0(r16) 		# load the OutputNote
	
	sthio r13,8(r8)			# push to the left channel
	sthio r13,12(r8)		# push to the right channel, note: Assumes both right channel and left channel are synchronize. 
	br LoopCalculateWave	# 

#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote1:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
  movia r16, PointerNote1		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
 # div r18, r18, r12		# Divide by global register number to divide r12
   srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote1			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote1Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote1
#-----------------------------
ActiveNote1Ret:

	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------

#----------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote2:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote2		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote2			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	ActiveNote2Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote2
 #-----------------------------
ActiveNote2Ret:

	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote3:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote3		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote3			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	ActiveNote3Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote3
 #-----------------------------
ActiveNote3Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------

#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote4:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote4		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote4			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	ActiveNote4Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote4
 #-----------------------------
ActiveNote4Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------



#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote5:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote5		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote5		#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote5Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote5
 #-----------------------------
ActiveNote5Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote6:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote6		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
   srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote6		#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	ActiveNote6Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote6
 #-----------------------------
ActiveNote6Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote7:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote7		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote7			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote7Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote7
 #-----------------------------
ActiveNote7Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------
 
#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote8:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote8		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote8			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote8Ret		#if the number of remaining samples =0 , then RESET2
  call ResetNote8
 #-----------------------------
ActiveNote8Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#----------------------------- 
 
#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote21:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
  movia r16, PointerNote21		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
 # div r18, r18, r12		# Divide by global register number to divide r12
   srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote21			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	Note21a		#if the number of remaining samples =0 , then RESET1
  call ResetNote21
  
Note21a:   
  movia r16, PointerNote21a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote21a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote21Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote21a
  
  
#-----------------------------
ActiveNote21Ret:

	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------

#----------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote22:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote22		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote22			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	Note22a		#if the number of remaining samples =0 , then RESET1
  call ResetNote22
  
Note22a:   
  movia r16, PointerNote22a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote22a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote22Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote22a
 #-----------------------------
ActiveNote22Ret:

	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote23:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote23		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote23			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	Note23a		#if the number of remaining samples =0 , then RESET1
  call ResetNote23
  
Note23a:   
  movia r16, PointerNote23a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote23a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote23Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote23a
 #-----------------------------
ActiveNote23Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------

#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote24:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote24		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote24			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	Note24a		#if the number of remaining samples =0 , then RESET
  call ResetNote24
  
Note24a:   
  movia r16, PointerNote24a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote24a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote24Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote24a
 #-----------------------------
ActiveNote24Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------



#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote25:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote25		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote25		#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	Note25a		#if the number of remaining samples =0 , then RESET1
  call ResetNote25
  
Note25a:   
  movia r16, PointerNote25a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote25a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote25Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote25a
 #-----------------------------
ActiveNote25Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote26:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote26		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
   srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote26		#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
#  andi r17, r17, 0x00001111
 #NOTE::: THE LDH ABOVE THIS LINE DOESNT WORK 
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  #NOTE: FIGURE OUT THE half word thing.
  bne r17, r0, 	Note26a		#if the number of remaining samples =0 , then RESET1
  call ResetNote26
  
Note26a:   
  movia r16, PointerNote26a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote26a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote26Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote26a
 #-----------------------------
ActiveNote26Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote27:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote27		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote27			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	Note27a		#if the number of remaining samples =0 , then RESET1
  call ResetNote27
  
Note27a:   
  movia r16, PointerNote27a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote27a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote27Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote27a
 #-----------------------------
ActiveNote27Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------


#----------------------------------------------------------------------------------------
# This function increments the final sample value if active note is called 
ActiveNote28:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------	
	
  movia r16, PointerNote28		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
    srai r18, r18, NUMBER_TO_DIVIDE

  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote28			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	Note28a		#if the number of remaining samples =0 , then RESET1
  call ResetNote28
  
Note28a:   
  movia r16, PointerNote28a		#mov the current pointer's address	
  ldw r17, 0(r16)				#points to an andress in memory: load the current pointer to the note1 array, r17 has the sample now
  ldw r18, 0(r17)				#is the value of the contents at the memory location specified above
  srai r18, r18, NUMBER_TO_DIVIDE
  add r4, r4, r18				# add the sample to the output and return the value
  addi r17, r17,4 				#increment the pointer in the array
  stw r17, 0(r16)				# Update Pointer Note 1's value which is the address of the memory 
  
  movia r16, CounterNote28a			#mov the address of index of note1
  ldw r17, 0(r16)				#ldh the value of index of note1
  
  subi r17, r17, 1				#decrement remaining samples
  stw r17, 0(r16)				#update the number of remaining samples
  bne r17, r0, 	ActiveNote28Ret		#if the number of remaining samples =0 , then RESET1
  call ResetNote28a
 #-----------------------------
ActiveNote28Ret:
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	add r2, r4, r0
	ret
#-----------------------------
 
 
 
#----------------------------------------------------------
# These functions do the same thing for different notes
#----------------------------------------------------------
#-----------------------------
# This function resets the pointer of the first note
ResetNote1:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote1		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote1	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote1	# Get address of the CounterNote1 register
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#----------------------------------------------------------

#-----------------------------
# This function resets Note 2
ResetNote2:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote2		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote2	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote2	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets Note 2
ResetNote3:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote3		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote3	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote3	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------
#-----------------------------
# This function resets Note 2
ResetNote4:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote4		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote4	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote4	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------


#-----------------------------
# This function resets Note 2
ResetNote5:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote5		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote5	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote5	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------



#-----------------------------
# This function resets Note 2
ResetNote6:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote6		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote6	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote6	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------


#-----------------------------
# This function resets Note 2
ResetNote7:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote7		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote7	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote7	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------
#-----------------------------
# This function resets Note 2
ResetNote8:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote8		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote8	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote8	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#----------------------------------------------------------
# These functions do the same thing for different notes
#----------------------------------------------------------
#-----------------------------
# This function resets the pointer of the first note
ResetNote21:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote21		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote21	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote21	# Get address of the CounterNote1 register
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote21a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote21a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote21	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote21a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#----------------------------------------------------------

#-----------------------------
# This function resets Note 2
ResetNote22:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote22		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote22	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote22	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote22a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote22a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote22	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote22a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets Note 2
ResetNote23:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote23		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote23	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote23	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote23a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote23a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote23	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote23a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets Note 2
ResetNote24:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote24		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote24	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote24	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote24a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote24a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote24	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote24a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets Note 2
ResetNote25:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote25		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote25	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote25	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote25a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote25a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote25	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote25a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------



#-----------------------------
# This function resets Note 2
ResetNote26:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote26		# pointer that points to the current sample of the array
	movia r17, Note2			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote26	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote26	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote26a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote26a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote26	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote26a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------
#-----------------------------
# This function resets Note 2
ResetNote27:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote27		# pointer that points to the current sample of the array
	movia r17, Note27			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote27	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote27	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote27a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote27a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote27	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote27a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets Note 2
ResetNote28:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote28		# pointer that points to the current sample of the array
	movia r17, Note28			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote28	# Get address to the sample size for note 2 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 2
	movia r16, CounterNote28	# Get address of the CounterNote2 register
	stw r18, 0(r16)		# store the value of the sample size to the counter, note:Counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------

#-----------------------------
# This function resets the pointer of the first note
ResetNote28a:
#-----------------------------
	#----------------------
	# Callee Save
	#----------------------
	subi sp, sp, 16
	stw r18, 12(sp)
	stw r17, 8(sp)
	stw r16, 4(sp)
	stw ra, 0(sp)
#-----------------------------
	movia r16, PointerNote28a		# pointer that points to the current sample of the array
	movia r17, Note1			# Actual pointer to the array 
	stw r17, 0(r16)			# Loads into the pointer the address of the array (address of the first element in the array) 
	
	movia r17, SampleSizeNote28	# Get address to the sample size for note 1 register
	ldw r18, 0(r17)		# Get the value of the sample size for note 1
	movia r16, CounterNote28a	# Get address of the CounterNote1 register
	subi r18, r18, 1 		# make it one less than actual size 
	stw r18, 0(r16)		# store the value of the sample size to the index, note: counter to check if it is 0, not the actual index into the array,
							# The index to the array is incremented each time IndexNote1 is reduce
#-----------------------------
	#----------------------
	# Callee Restore
	#----------------------
	ldw ra, 0(sp) # load return address
	ldw r16, 4(sp)
	ldw r17, 8(sp)
	ldw r18, 12(sp)
	addi sp, sp, 16
#-----------------------------
	ret
#-----------------------------